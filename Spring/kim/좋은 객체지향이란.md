# 좋은 객체지향 설계의 5가지 원칙(SOLID)     
Spring Framework란 객체지향 언어가 가진 강력한 특징을 살려내는 프레임워크다.     
즉, 좋은 객체지향 어플리케이션을 개발할 수 있도록 도와주는 프레임워크이다.     
    
그렇다면 **좋은 객체지향 프로그램**이란 무엇일까?   
→ 유연하고 변경에 용이한 프로그램 = 컴포넌트를 컴퓨터 부품 갈아끼우듯이 쉽고 유연하게 갈아끼울 수 있는 것    
**다형성(Polymorphism)이 핵심!**


## 1. 좋은 객체지향 프로그램이란?     

<div align="center">
  <img src="https://user-images.githubusercontent.com/84266499/164978544-0991880a-c18d-465b-ab31-43d389b9693e.png" width="80%" height="80%"/>
</div>
<br>

위 예시에서 운전자가 운전할 자동차의 구현객체가 바뀐다고 해도 운전 방법이 바뀌거나 운전면허를 따야하는 것이 아니다.     
즉, 클라이언트는 구현 객체의 내부 구조는 몰라도 되고, 인터페이스에 대해서만 알면 된다.     
그렇기 때문에 인터페이스를 바탕으로 클라이언트의 변경 없이 다른 자동차를 무한히 생성하거나 변경하는 것이 가능하다.     
    
**인터페이스를 구현한 객체 인스턴스를 실행시점에 유연하게 변경할 수 있으며, 클라이언트를 변경하지 않고 서버의 기능을 유연하게 변경할 수 있다는 것이 Spring과 다형성의 핵심이다!**    
     

## 2. 좋은 객체지향 설계의 5가지 원칙     
### 2.1. SRP(Single Reponsibility Principle): 단일 책임 원칙     
- **하나의 클래스는 하나의 책임만 가져야 한다** → 그렇다면 하나의 책임이란?
   
중요한 기준은 **변경**이다. 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른 것이다.    
변경 사항이 생겼을 때 한 클래스의 한 부분만 고치면 되는 경우 SRP를 잘 지킨 것.     

기능의 단위를 너무 잘게 쪼개면 관리가 어렵고 너무 크게 쪼개면 책임이 많아져서 SRP가 깨질 수 있기 때문에 적절히 잘 설계하는 것이 중요하다.   

### 2.2. OCP(Open/Closed Principle): 개방-폐쇠 원칙📌
소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다.     
      
만약 아래와 같은 상황에서....

<div align="center">
  <img src="https://user-images.githubusercontent.com/84266499/164979333-181d485e-a28a-4021-a724-f1a47449f696.png" width="70%" height="70%"/>
</div>
<br>

클라이언트가 새로 스포츠카를 타려고 한다고 가정하자.    
그러면 기존 K3나 자동차 인터페이스의 변경 없이 자동차 인터페이스를 구현한 새 스포츠카 객체만 만들어주면 된다.    
이것이 바로 확장에는 열려있으나 변경에는 닫혀있어야한다는 의미이다.     
     
하지만 스포츠카라는 구현 객체로 자동차를 변경하려 할 때 클라이언트가 직접 자동차 구현객체를 변경한다면 클라이언트 코드의 변화가 일어나게 된다.    
즉, OCP가 위배되는 상황.    
이러한 상황에서 OCP가 위배되지 않게 하려면 클라이언트가 직접 자동차를 바꾸는 것이 아니라 자동차 대리점 등에서 자동차를 바꿔주는 형태여야 함     
     
즉, 객체를 생성하고 관계를 맺어주는 별도의 조립,설정자가 필요하다(DI, Ioc 컨테이너)     


### 2.3. LSP(Liskov Substitution Principle): 리스코프 치환 원칙
프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.     
     
컴파일 단위의 원칙이 아님. 프로그램이 약속된 대로 동작해야 한다는 원칙
ex) 자동차 인터페이스에서 브레이크는 멈추는 기능을 담당해야 함. 브레이크를 밟아도 멈추지 않는다면 LSP를 위반한 것

### 2.4. ISP(Interface Segregation Principle): 인터페이스 분리 원칙
특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.     

- 기능의 단위를 너무 크게 잡지 말고 적절한 단위로 잘게 쪼개는 것이 중요하다.
ex) 자동차 인터페이스 하나보다는 `운전 인터페이스`와 `정비 인터페이스` 두 가지 인터페이스로 나누어 관리하는 것이 더 좋다.
    인터페이스가 명확해지고, 대체 가능성이 높아진다.   

### 2.5. DIP(Dependency Injection Principle): 의존관계 역전 원칙📌
프로그래머는 **추상화에 의존해야지 구체화에 의존하면 안된다.**     
= 구현 클래스에 의존하지 말고 인터페이스에 의존하라는 의미이다.    
      
의존자는 "자동차 운전하는 방법"에 대해서 알아야지 K3에 구제에 대해서는 알 필요가 없음     

````java
Car car = new K3();
````
위와 같은 코드가 DIP를 위배하는 코드인데, 언뜻 보면 `Car` 인터페이스 객체를 사용하기 때문에 인터페이스에 의존하고 있는 것 처럼 보이지만, 
구현 객체인 `K3`객체가 대입되고 있다. 이럴 경우 추상화+구체화 모두에 의존하게 된다.    
이러면 DIP가 위배될 뿐만 아니라 자동차를 바꾸려고 할 때 `new K3()`에서 `new Avante()`로 바꾸는 등 클라이언트 코드의 변화까지 일어난다.   
즉, DIP와 OCP를 모두 위배하게 된다는 뜻     



